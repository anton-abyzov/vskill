# MirrorMaker 2 Configuration
# Replicates topics between source and target Kafka clusters

# ========================================
# CLUSTER CONNECTION CONFIGURATION
# ========================================

# Source cluster (primary)
clusters = source, target

source.bootstrap.servers = source-kafka-1:9092,source-kafka-2:9092,source-kafka-3:9092
source.security.protocol = SASL_SSL
source.sasl.mechanism = SCRAM-SHA-512
source.sasl.jaas.config = org.apache.kafka.common.security.scram.ScramLoginModule required \
    username="source-user" \
    password="source-password";

# Target cluster (replica)
target.bootstrap.servers = target-kafka-1:9092,target-kafka-2:9092,target-kafka-3:9092
target.security.protocol = SASL_SSL
target.sasl.mechanism = SCRAM-SHA-512
target.sasl.jaas.config = org.apache.kafka.common.security.scram.ScramLoginModule required \
    username="target-user" \
    password="target-password";

# ========================================
# REPLICATION FLOWS
# ========================================

# Define replication flows (source -> target)
source->target.enabled = true

# Topic whitelist (regex)
# Replicate all topics except internal topics
source->target.topics = .*
source->target.topics.blacklist = __.*,_.*

# Create topics on target with same configuration
source->target.sync.topic.configs.enabled = true
source->target.sync.topic.configs.interval.seconds = 60

# Sync ACLs from source to target
source->target.sync.topic.acls.enabled = true
source->target.sync.topic.acls.interval.seconds = 600

# ========================================
# OFFSET SYNC CONFIGURATION
# ========================================

# Sync consumer group offsets from source to target
# Allows consumers to fail over to target cluster
source->target.emit.checkpoints.enabled = true
source->target.emit.checkpoints.interval.seconds = 60

# Offset translation (source partition -> target partition)
source->target.offset-syncs.topic.replication.factor = 3
source->target.offset-syncs.topic.location = target

# Sync interval for offset mapping
source->target.sync.group.offsets.enabled = true
source->target.sync.group.offsets.interval.seconds = 60

# Consumer groups to replicate (regex)
source->target.groups = .*
source->target.groups.blacklist = console-consumer-.*,connect-.*

# ========================================
# CHECKPOINT CONFIGURATION
# ========================================

# Checkpoint storage (Kafka topic on target cluster)
source->target.checkpoints.topic.replication.factor = 3
checkpoints.topic.replication.factor = 3

# Emit heartbeats to track replication lag
source->target.emit.heartbeats.enabled = true
source->target.emit.heartbeats.interval.seconds = 5
heartbeats.topic.replication.factor = 3

# ========================================
# PERFORMANCE TUNING
# ========================================

# Tasks (parallelism)
# Higher = faster replication, more resource usage
tasks.max = 10

# Replication throughput
# Max bytes/sec per task (0 = unlimited)
source->target.max.tasks = 10
source->target.throughput.bytes.per.second = 104857600  # 100 MB/s

# Consumer fetch size
source->target.consumer.max.poll.records = 1000
source->target.consumer.fetch.max.bytes = 52428800  # 50 MB

# Producer batch size
source->target.producer.batch.size = 32768  # 32 KB
source->target.producer.linger.ms = 10
source->target.producer.compression.type = lz4

# ========================================
# REPLICATION POLICY
# ========================================

# Naming convention for replicated topics
# Options: DefaultReplicationPolicy, IdentityReplicationPolicy
replication.policy.class = org.apache.kafka.connect.mirror.DefaultReplicationPolicy

# Topic name prefix (default: source cluster alias + ".")
# Example: "orders" -> "source.orders"
# Set to "" for IdentityReplicationPolicy (no prefix)
replication.policy.separator = .

# ========================================
# INTERNAL TOPICS CONFIGURATION
# ========================================

# MirrorMaker 2 internal topics
# These store checkpoints, offsets, and metadata
offset-syncs.topic.replication.factor = 3
heartbeats.topic.replication.factor = 3

# Retention for internal topics
offset.storage.topic = mm2-offset-syncs.source.internal
offset.storage.replication.factor = 3
offset.storage.partitions = 25

config.storage.topic = mm2-configs.source.internal
config.storage.replication.factor = 3

status.storage.topic = mm2-status.source.internal
status.storage.replication.factor = 3
status.storage.partitions = 5

# ========================================
# FAILOVER CONFIGURATION
# ========================================

# When failing over from source to target:
# 1. Stop producers on source
# 2. Wait for replication lag to reach 0
# 3. Redirect consumers to target cluster
# 4. Consumers will resume from last committed offset (synced by MirrorMaker 2)

# Monitor replication lag via heartbeats topic:
# kafka-console-consumer --bootstrap-server target:9092 \
#   --topic heartbeats \
#   --from-beginning

# Check offset sync status:
# kafka-console-consumer --bootstrap-server target:9092 \
#   --topic mm2-offset-syncs.source.internal \
#   --from-beginning

# ========================================
# BIDIRECTIONAL REPLICATION (ACTIVE-ACTIVE)
# ========================================

# For active-active setups, enable reverse flow:
# target->source.enabled = true
# target->source.topics = .*
# target->source.topics.blacklist = __.*,_.*,source.*

# WARNING: Bidirectional replication requires careful design
# to avoid replication loops. Use topic prefixes to prevent loops.

# ========================================
# MONITORING
# ========================================

# MirrorMaker 2 exposes JMX metrics:
# - kafka.connect.mirror:type=MirrorSourceConnector,target=*,topic=*,partition=*
#   - record-count (total records replicated)
#   - record-age-ms (replication lag in ms)
#   - replication-latency-ms (end-to-end latency)
#
# - kafka.connect.mirror:type=MirrorCheckpointConnector
#   - checkpoint-latency-ms (offset sync lag)

# Prometheus JMX Exporter config:
# - Check replication lag: record-age-ms < 5000 (5s)
# - Alert on high lag: record-age-ms > 60000 (1 minute)

# ========================================
# USAGE EXAMPLES
# ========================================

# Start MirrorMaker 2 (standalone mode):
# connect-mirror-maker.sh mirrormaker2-config.properties

# Start MirrorMaker 2 (distributed mode):
# 1. Start Connect workers on 3+ nodes
# 2. Create MirrorSourceConnector via REST API
# 3. Create MirrorCheckpointConnector via REST API
# 4. Create MirrorHeartbeatConnector via REST API

# Verify replication:
# kafka-topics --bootstrap-server target:9092 --list | grep source.
# kafka-consumer-groups --bootstrap-server target:9092 --list

# ========================================
# BEST PRACTICES
# ========================================

# 1. Replication Factor: Match source cluster RF (typically 3)
# 2. Tasks: Start with 10, increase if lag is high
# 3. Throughput Limits: Set per-task limit to prevent network saturation
# 4. Topic Filters: Use whitelist to avoid replicating unnecessary topics
# 5. Offset Sync: Enable for seamless consumer failover
# 6. Monitoring: Track replication lag, alert if > 1 minute
# 7. Testing: Test failover procedure regularly (quarterly)
# 8. Security: Use SASL/SSL for both clusters
# 9. Network: Ensure low latency between clusters (< 50ms)
# 10. Disaster Recovery: Document failover/failback procedures

# ========================================
# COMMON ISSUES & SOLUTIONS
# ========================================

# Issue: High replication lag
# Solution: Increase tasks.max, check network bandwidth

# Issue: Offset sync not working
# Solution: Verify emit.checkpoints.enabled = true, check consumer group names

# Issue: Duplicate messages on failover
# Solution: Use exactly-once semantics (transactional producers + read_committed consumers)

# Issue: Topics not created on target
# Solution: Enable sync.topic.configs.enabled, check topic ACLs

# Issue: Replication loop (bidirectional)
# Solution: Use topic prefixes, configure blacklist properly
